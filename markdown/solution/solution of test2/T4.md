dp ~~水题~~

其实一般的方程式不怎么难想

$dp[i][j][k]$ 可以表示在时间 $i$
在工厂 $j$ 当机器人之前已经走了 $k$ 步的方案。
然后通过滚动数组可以把 $k$ 那一维消去

变成
$dp[i][j][1 or 0]$ 表示在时间 $i$ 在工厂 $j$
是否能够再走。

然后列出状态转移方程式：

$dp[i][j][1] = max (dp[i][j][1], dp[i - k][j - k][0] + calc (i, j, k))$

没有0的因为这个有bug

这个题把 *点权* 释放在了 *点权* 上

其实就是储存的路径位置其实就是某个点伸出去的那一条

image1

比如用*图* 来描述读入的某时间某费用数组
$dp[i][j]$ 表示时间 $i$ 位置 $j$ 所延伸回去
的 $45°$ 的链的值，如下图，黄点为 $(i,j)$ 的位置，则它所代表的链为蓝色的一条链上的点权之和。

image2

然后可以写calc了
如下图，它要返回这样一个链的值

image2

然后可以写代码了
```cpp
int calc (int i, int j, int k) {
    return f[i - 1][j - 1] - f[i - k - 1][j - k - 1];
}
```
但是你在考虑拐弯的时候会懵逼的发现。。。

image3

然后发现有亿点麻烦。。。

这是带拐弯的转移：
$dp[i][j][1] = max (dp[i][j][1], dp[i - k][n + j - k][0] + calc (i - j + 1, n + 1, k - j + 1) + calc (i, j, j - 1))$

然后你斩获了90pts

-----

你发现自己的方程过于不优秀了，于是你想了另外一种方案。

$dp[i]$ 表示时间 $i$ 的最大答案。

转移方程式：

$dp[i] = max (dp[i - k] + calc (i, j, k) - cost[j - k])$ 无环嗷嗷嗷

然后你看着减去的 $cost$ 仍然没有定义，然后你发现应该给 ta 一个定语

$dp[i]$ 表示时间 $i$ 处在某位置上还未在此位置上消费机器人的最大答案，每一步的机器人花费是在被转移的时候才扣得啊。而我最初的方程，是代表当前时间ii和地点jj已经买了机器人的最大答案。为了区分是否处理花费机器人的状态，我甚至得用第三维的 $0/1$ 维护。

然后发现自己读题读错了，没听懂的罚你再看几遍题

然后通过这个优秀的方程式，哪怕这是 $O(n^3)$ 的垃圾复杂度也可以问问卡过。

----

但是多事的你并不想这样卡过去，你想用一种复杂度正确的方式通过这道题

我们考虑使用单调队列优化 $dp$

Tips: 现在我的编号和时间减掉了一，开心麻了

image4

这样我们查询 $dp_[i][j]$ 所代表的就不仅仅是多延伸出去一条链了，舒服麻了

然后我们再列出改装过的转移方程：

$dp[i] = max (dp[i - k] + dp_[i][j] - dp_[i - k][j - k] - cost[j - k]) = max (dp[i - k] - dp_[i - k][j - k] - cost[j - k]) + dp_[i][j]$

转移时使用单调队列维护一下 $matrix[i][j] = dp[i] - dp_[i][j] - cost[j]$ 便可

因为每一个 $dp_[i][j]$ 都可以唯一的确定一个 $dp[i]$ 和 $cost[j]$
，所以我们考虑 $dp_[i][j]$ 在转移是的分布。

image5

对于同一个答案的贡献，这个分布大概是这样。

为了准确的定位某个答案从哪个单调队列转移，考虑给每一个单调队列编号，将单队与 $location$ 轴相交的那个点作为它的编号。

还没拐弯的时候，所属的单调队列即为 $j - i$ ，拐弯了以后我们它减去了 $l$ 个 $n$ ，$l$ 为拐弯次数。

很简单，取模再加一边即可

```cpp
int get (int x, int y) {
  return ((j - i) % n + n) % n;
}
```

有两点需要注意的地方。

一是虚线所连的边任然需要特判一下，二是为了确保拐弯了之后不会出现问题，要把 $dp[i] = max (dp[i - k], dp_[i - k][j - k] - cost[j - k]) + dp_[i][j]$ 中的 $dp_[i][j]$ 加上它失去的链的长度，维护一个 $sum[i]$ 数组。